import os
import json
import logging
import re
from flask import Flask, request, jsonify
from telegram import Update, Bot
from telegram.ext import Dispatcher, CommandHandler, ContextTypes, MessageHandler, filters
from telegram.constants import ParseMode

# Import the scanner logic
from scanner_logic import get_token_details

# --- Configuration and Initialization ---
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Flask application setup
app = Flask(__name__)

# Mandatory Environment Variables (Must be set on your free hosting platform)
BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN")
WEBHOOK_URL_BASE = os.environ.get("WEBHOOK_URL_BASE") 

if not BOT_TOKEN or not WEBHOOK_URL_BASE:
    logger.error("!!! FATAL: TELEGRAM_BOT_TOKEN or WEBHOOK_URL_BASE environment variables are not set. !!!")
    
# --- Telegram Bot Setup ---

# Initialize Bot and Dispatcher globally
bot = Bot(token=BOT_TOKEN)
dispatcher = Dispatcher(bot, None)

# --- Command Handlers ---

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Sends a welcome message."""
    await update.message.reply_text(
        "ðŸ‘‹ Welcome to the Free Contract Scanner Bot!\n\n"
        "To scan a contract, use the command:\n"
        "`/scan <CONTRACT_ADDRESS>`\n\n"
        "Example: `/scan 0x8929949dF72b141A90E355f32E318536f9c4501b`",
        parse_mode=ParseMode.MARKDOWN
    )

async def scan_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handles the /scan command and calls the scanner logic."""
    args = context.args
    if not args:
        await update.message.reply_text(
            "Please provide a Contract Address after the /scan command.\n"
            "Example: `/scan 0x123...`",
            parse_mode=ParseMode.MARKDOWN
        )
        return

    contract_address = args[0].strip()
    if not re.match(r'^0x[a-fA-F0-9]{40}$', contract_address):
        await update.message.reply_text(
            f"âŒ The address format looks invalid: `{contract_address}`.",
            parse_mode=ParseMode.MARKDOWN
        )
        return
    
    await update.message.reply_text(f"ðŸ” Scanning contract: `{contract_address}`...")

    # Call the Blockchain Logic
    results = get_token_details(contract_address)

    # Format and Send Results
    if results["status"] == "success":
        message_text = (
            f"âœ… **Scan Complete**\n\n"
            f"**Contract Address:** `{results['address']}`\n"
            f"**Token Name:** `{results['name']}`\n"
            f"**Token Symbol:** `{results['symbol']}`"
        )
    else:
        message_text = (
            f"âŒ **Scan Failed**\n\n"
            f"**Address:** `{contract_address}`\n"
            f"**Reason:** {results['message']}"
        )

    await update.message.reply_text(message_text, parse_mode=ParseMode.MARKDOWN)

async def unknown_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle unknown messages."""
    await update.message.reply_text(
        "I only understand the `/scan` command. Please use `/start` for instructions.",
        parse_mode=ParseMode.MARKDOWN
    )

# Register handlers with the dispatcher
dispatcher.add_handler(CommandHandler("start", start_command))
dispatcher.add_handler(CommandHandler("scan", scan_command))
dispatcher.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, unknown_message))


# --- Flask Webhook Route ---

@app.route('/webhook', methods=['POST'])
def webhook_handler():
    """Receives and processes incoming Telegram updates."""
    if request.method == "POST":
        update_data = request.get_json(force=True)
        try:
            update = Update.de_json(update_data, bot)
            # Process the update using the dispatcher
            dispatcher.process_update(update)
        except Exception as e:
            logger.error(f"Error processing update: {e}", exc_info=True)

    # Always return 200 OK to Telegram quickly
    return 'ok', 200

@app.route('/', methods=['GET'])
def set_and_test_webhook():
    """
    Sets the Telegram webhook when the root URL is accessed, and confirms bot status.
    This runs once on deployment to configure Telegram.
    """
    webhook_url = f"{WEBHOOK_URL_BASE}/webhook"
    
    try:
        # Set the webhook URL with Telegram's API
        set_result = bot.set_webhook(url=webhook_url)
        
        if set_result:
            return jsonify({
                "status": "success",
                "message": "Webhook set successfully!",
                "webhook_url_configured": webhook_url
            }), 200
        else:
            return jsonify({
                "status": "error",
                "message": "Failed to set webhook. Check your Bot Token and URL."
            }), 500

    except Exception as e:
        logger.error(f"Error setting webhook: {e}", exc_info=True)
        return jsonify({
            "status": "error",
            "message": f"Critical error setting webhook: {str(e)}"
        }), 500

# --- Standard Flask Run Block ---
if __name__ == '__main__':
    # This is mainly for local testing. On Render/Railway, they provide the PORT environment variable.
    PORT = int(os.environ.get("PORT", 5000))
    app.run(host="0.0.0.0", port=PORT)

