import os
import logging
import re
from flask import Flask, request, jsonify
from telegram import Update, Bot
from telegram.ext import Dispatcher, CommandHandler, ContextTypes, MessageHandler, filters
from telegram.constants import ParseMode

# The critical line: imports the scanner_logic module
from scanner_logic import get_token_details

# --- Configuration and Initialization ---
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)

# IMPORTANT: These must be set as environment variables on your hosting platform!
BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN")
WEBHOOK_URL_BASE = os.environ.get("WEBHOOK_URL_BASE") 
    
if BOT_TOKEN:
    bot = Bot(token=BOT_TOKEN)
    dispatcher = Dispatcher(bot, None)
else:
    logger.error("BOT_TOKEN is missing. Bot functionality disabled.")
    dispatcher = None


# --- Command Handlers ---

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(
        "ðŸ‘‹ Welcome to The Block Eye Scanner!\n\n"
        "To scan a contract, use the command:\n"
        "`/scan <CONTRACT_ADDRESS>`\n\n"
        "Example: `/scan 0x8929949dF72b141A90E355f32E318536f9c4501b`",
        parse_mode=ParseMode.MARKDOWN
    )

async def scan_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    args = context.args
    if not args:
        await update.message.reply_text(
            "Please provide a Contract Address after the /scan command.",
            parse_mode=ParseMode.MARKDOWN
        )
        return

    contract_address = args[0].strip()
    if not re.match(r'^0x[a-fA-F0-9]{40}$', contract_address):
        await update.message.reply_text(
            f"âŒ The address format looks invalid: `{contract_address}`.",
            parse_mode=ParseMode.MARKDOWN
        )
        return
    
    await update.message.reply_text(f"ðŸ” Scanning contract: `{contract_address}`...")

    # Call the Blockchain Logic
    results = get_token_details(contract_address)

    # Format and Send Results
    if results["status"] == "success":
        message_text = (
            f"âœ… **Scan Complete**\n\n"
            f"**Contract Address:** `{results['address']}`\n"
            f"**Token Name:** `{results['name']}`\n"
            f"**Token Symbol:** `{results['symbol']}`"
        )
    else:
        message_text = (
            f"âŒ **Scan Failed**\n\n"
            f"**Address:** `{contract_address}`\n"
            f"**Reason:** {results['message']}"
        )

    await update.message.reply_text(message_text, parse_mode=ParseMode.MARKDOWN)

async def unknown_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(
        "I only understand the `/scan` command. Please use `/start` for instructions.",
        parse_mode=ParseMode.MARKDOWN
    )

# Register handlers
if dispatcher:
    dispatcher.add_handler(CommandHandler("start", start_command))
    dispatcher.add_handler(CommandHandler("scan", scan_command))
    dispatcher.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, unknown_message))


# --- Flask Webhook Route ---

@app.route('/webhook', methods=['POST'])
def webhook_handler():
    """Receives and processes incoming Telegram updates."""
    if request.method == "POST" and dispatcher:
        update_data = request.get_json(force=True)
        try:
            update = Update.de_json(update_data, dispatcher.bot)
            dispatcher.process_update(update)
        except Exception as e:
            logger.error(f"Error processing update: {e}", exc_info=True)

    return 'ok', 200

@app.route('/', methods=['GET'])
def set_and_test_webhook():
    """
    Sets the Telegram webhook when the root URL is accessed.
    """
    if not WEBHOOK_URL_BASE or not BOT_TOKEN:
        return jsonify({
            "status": "error",
            "message": "Configuration error: Missing BOT_TOKEN or WEBHOOK_URL_BASE environment variables."
        }), 500

    webhook_url = f"{WEBHOOK_URL_BASE}/webhook"
    
    try:
        set_result = bot.set_webhook(url=webhook_url)
        
        if set_result:
            return jsonify({
                "status": "success",
                "message": "Webhook set successfully! The bot is ready to receive messages.",
                "webhook_url_configured": webhook_url
            }), 200
        else:
            return jsonify({
                "status": "error",
                "message": "Failed to set webhook. Check your Bot Token."
            }), 500

    except Exception as e:
        logger.error(f"Error setting webhook: {e}", exc_info=True)
        return jsonify({
            "status": "error",
            "message": f"Critical error setting webhook: {str(e)}"
        }), 500

# --- Standard Flask Run Block ---
if __name__ == '__main__':
    PORT = int(os.environ.get("PORT", 5000))
    app.run(host="0.0.0.0", port=PORT)

